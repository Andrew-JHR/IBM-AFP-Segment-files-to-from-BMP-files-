// Bmp2PsegDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Bmp2Pseg.h"
#include "Bmp2PsegDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBmp2PsegDlg dialog

CBmp2PsegDlg::CBmp2PsegDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CBmp2PsegDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CBmp2PsegDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CBmp2PsegDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBmp2PsegDlg)
	DDX_Control(pDX, IDC_WHO, m_WHO);
	DDX_Control(pDX, IDC_PSEG, m_PSEG);
	DDX_Control(pDX, IDC_BMP, m_BMP);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CBmp2PsegDlg, CDialog)
	//{{AFX_MSG_MAP(CBmp2PsegDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDABOUT, OnAbout)
	ON_BN_CLICKED(IDC_XLAT, OnXlat)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBmp2PsegDlg message handlers

BOOL CBmp2PsegDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	m_BMP.SetWindowText("d:\\s1cobtpe.bmp");   // display the default input file name
	m_PSEG.SetWindowText("d:\\S1COBTPE");		// display the default output file name
	m_WHO.SetWindowText("Anoymous");	// display the default user name 

	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CBmp2PsegDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CBmp2PsegDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CBmp2PsegDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CBmp2PsegDlg::OnAbout() 
{
	CAboutDlg dlg;
	dlg.DoModal();   // display the about message as a sort of 'readme'
}

void CBmp2PsegDlg::OnXlat() 
{

	void xcode(unsigned char *,int);
	CString infile = "d:\\s1cobtpe.bmp" ;
	CString outfile = "d:\\S1COBTPE" ;
	CString ImageWho =  "Anoymous" ;
	char ImageRemark[150] = "Image Created by "; 
	

	char ProgRemark[] = "Generated by BMP2PSEG.exe 14/Nov/2002";
	char ProgAuthor[] = "Program Author : Andrew Jan";

	char PsegName[9] ;
	char ImageName[9] ;

	unsigned char RecLen[2];


	m_BMP.GetWindowText(infile);		// get the input BMP file name
	m_PSEG.GetWindowText(outfile);		// get the output Page Segment file name
	m_WHO.GetWindowText(ImageWho);		// get the user name

	//construct the Page Segment File name from the output file name
	LPCTSTR lp = outfile;
	int j = outfile.GetLength();	// string length in j
	for (int i=0 ; i < j ; i++,lp++) 
	{
		if (*lp == '\\')
			break;
	}

	if ( i >= j)		// prevent that if no folder is specified
		lp = outfile ;
	else
		lp++;
	

	for (i=0 ; i < 8 ; i++, lp++)	// construct the Page Segment first	
	{
		if ( (*lp == '\0') || (*lp == ' ') || (*lp == '.') )	//file name less than 8 bytes
		{
			for (j=i; j< 8 ; j++)
				PsegName[j] = ' ';
			break;
		}
		else 
		{
			PsegName[i] = *lp;
		}
	}

	memcpy(ImageName,PsegName,8);  //copy the same name to Image name

	ifstream input;
	ofstream output;

	union                                      // input image file maps
	{
	//	unsigned char inbuf[5000];
		unsigned char inbuf[500];
		BMPhdr   Header;
	};

//	unsigned char outbuf[30000];
	unsigned char *p , *q ;

	int ImageWidth, ImageHeight, bits ;

	input.open(infile,ios::binary | ios::nocreate);		// open the page segment file
	if (!input)
	{
		AfxMessageBox(" Open Input File Error ! ") ;	// error message
		return;
	}
		
	
	input.read(inbuf,sizeof(BMPhdr));

	ImageWidth  = Header.width;
	ImageHeight = Header.height;
	bits        = Header.bitpix;

	if ( (ImageWidth%8) > 0 )
	{
		AfxMessageBox(" Please Make the Pixel Number of the Width a Multiple of 8 ! ") ;	// error message
		input.close();
		return;
	}

	unsigned char * ibfrptr = new unsigned char[ImageWidth*bits/4];
	unsigned char * obfrptr = new unsigned char[ImageWidth*ImageHeight/8+1000];


	output.open(outfile,ios::binary);
	if (!output)
	{
		AfxMessageBox(" Open Output File Error !") ;
		return;
	}  


	// print the first comment line in ascii
	RecLen[0] = (strlen(ProgRemark)+8) / 0x100;
	RecLen[1] = (strlen(ProgRemark)+8) % 0x100;
	output.put('Z');
	output.write(RecLen,2);
	output.write(Image_Comment,sizeof(Image_Comment));
	output.write(lowvalue,3);
	output.write(ProgRemark,strlen(ProgRemark));
	// print the first comment line in ebcdic
	output.put('Z');
	output.write(RecLen,2);
	output.write(Image_Comment,sizeof(Image_Comment));
	output.write(lowvalue,3);
	xcode((unsigned char *)ProgRemark,strlen(ProgRemark));
	output.write(ProgRemark,strlen(ProgRemark));


	// print the second comment line in ascii
	RecLen[0] = (strlen(ProgAuthor)+8) / 0x100;
	RecLen[1] = (strlen(ProgAuthor)+8) % 0x100;
	output.put('Z');
	output.write(RecLen,2);
	output.write(Image_Comment,sizeof(Image_Comment));
	output.write(lowvalue,3);
	output.write(ProgAuthor,strlen(ProgAuthor));
	// print the second comment line in ebcdic
	output.put('Z');
	output.write(RecLen,2);
	output.write(Image_Comment,sizeof(Image_Comment));
	output.write(lowvalue,3);
	xcode((unsigned char *)ProgAuthor,strlen(ProgAuthor));
	output.write(ProgAuthor,strlen(ProgAuthor));

	// print the third comment line in ascii
	struct tm *loctime;
	time_t    longtime;
	time(&longtime);	// get current time
	loctime = localtime(&longtime);	// translate into local time
	strcat(ImageRemark,ImageWho);	// get who is creating this image
	strcat(ImageRemark,",");		// delimitor
	strcat(ImageRemark,asctime(loctime));	// append the local date/time this image is created
	RecLen[0] = (strlen(ImageRemark)+8) / 0x100;
	RecLen[1] = (strlen(ImageRemark)+8) % 0x100;
	output.put('Z');
	output.write(RecLen,2);
	output.write(Image_Comment,sizeof(Image_Comment));
	output.write(lowvalue,3);
	output.write(ImageRemark,strlen(ImageRemark));

	// print the third comment line in ebcdic
	output.put('Z');
	output.write(RecLen,2);
	output.write(Image_Comment,sizeof(Image_Comment));
	output.write(lowvalue,3);
	xcode((unsigned char *)ImageRemark,strlen(ImageRemark));
	output.write(ImageRemark,strlen(ImageRemark));



	//print the Begin Page Segment line
	RecLen[0] = 0x00;   // Page Segment name and Image name are both 8 bytes long
	RecLen[1] = 0x10;
	output.put('Z');
	output.write(RecLen,2);
	output.write(Begin_Page_Segment,sizeof(Begin_Page_Segment));
	output.write(lowvalue,3);
	xcode((unsigned char *)PsegName,8);	//xlate into ebcdic
	output.write(PsegName,8);
	
	// print the Begin Image line 
	output.put('Z');
	output.write(RecLen,2);
	output.write(Begin_Image,sizeof(Begin_Image));
	output.write(lowvalue,3);
	xcode((unsigned char *)ImageName,8);
	output.write(ImageName,8);


	// print the Image Output Control line
	RecLen[0] = (sizeof(IOC_data)+8) / 0x100;
	RecLen[1] = (sizeof(IOC_data)+8) % 0x100;
	output.put('Z');
	output.write(RecLen,2);
	output.write(Image_Output_Control,sizeof(Image_Output_Control));
	output.write(lowvalue,3);
	output.write(IOC_data,sizeof(IOC_data));
	

		
	// print the Image Output Control line
	output.put('Z');
	RecLen[0] = (sizeof(IID_data_1)+4+sizeof(IID_data_2)+8) / 0x100;
	RecLen[1] = (sizeof(IID_data_1)+4+sizeof(IID_data_2)+8) % 0x100;
	output.write(RecLen,2);
	output.write(Image_Input_Desc,sizeof(Image_Input_Desc));
	output.write(lowvalue,3);
	output.write(IID_data_1,sizeof(IID_data_1));
	RecLen[0] = ImageWidth / 0x100;		
	RecLen[1] = ImageWidth % 0x100;
	output.write(RecLen,2);
	RecLen[0] = ImageHeight / 0x100;
	RecLen[1] = ImageHeight % 0x100;
	output.write(RecLen,2);
	output.write(IID_data_2,sizeof(IID_data_2));


//	q = outbuf; // locate the start of the out buffer
	q = obfrptr;

	for (j=0 ; j < ImageHeight ; j++)
	{
//		input.read(inbuf,(ImageWidth * bits/8));
		input.read(ibfrptr,(ImageWidth * bits/8));

//		p = inbuf;
		p = ibfrptr;

		for (int i=0 ; i < ImageWidth/8 ; i++, q++)
		{
			*q = 0x00;
			for (int k = 0 ; k < 8 ; k++, p += bits/8)
			{
				if ( *p == 0x00 )
					*q = *q | (0x80 >> k) ;
			}
		} 
	} // end of for looping ImageHeight's times


	input.close(); // close input file


	RecLen[0] = (ImageWidth/8+8) / 0x100;
	RecLen[1] = (ImageWidth/8+8) % 0x100;

//	q = outbuf + (ImageHeight-1)*ImageWidth/8 ;
	q = obfrptr + (ImageHeight-1)*ImageWidth/8 ;
	for (i = 0 ; i < ImageHeight ; i++, q -= ImageWidth/8)
	{
		output.put('Z');
		output.write(RecLen,2);
		output.write(Image_Raster_Data,sizeof(Image_Raster_Data));
		output.write(lowvalue,3);
		output.write(q,ImageWidth/8);
	}
    
	delete [] ibfrptr;
	delete [] obfrptr;


	// print the End Image line 
	RecLen[0] = 0x00;   // Page Segment name and Image name are both 8 bytes long
	RecLen[1] = 0x10;
	output.put('Z');
	output.write(RecLen,2);
	output.write(End_Image,sizeof(End_Image));
	output.write(lowvalue,3);
	output.write(ImageName,8);

	//print the End Page Segment line
	output.put('Z');
	output.write(RecLen,2);
	output.write(End_Page_Segment,sizeof(End_Page_Segment));
	output.write(lowvalue,3);
	output.write(PsegName,8);
	
	output.close() ;	// close output file

	AfxMessageBox(" Successfully Completed ! ") ;	// error message

	return ;
	
}

void xcode(unsigned char* bufptr, int len)
{
	for (int i=0 ; i < len ; i++)
	{
		*bufptr = asc2ebc[(*bufptr)];
		bufptr++ ;
	}
	*bufptr = '\0';
} 
